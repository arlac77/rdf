#!/usr/bin/env iojs

/* jslint node: true, esnext: true */

"use strict";

var fs = require('co-fs');
var co = require('co');
var Commander = require('commander');
var sparql = require('../lib/sparql');

Commander
	.option('-s --scenario <scenario>', 'use scenario')
	.option('-m --mapping <magging>', 'mapping scenario <-> rdf')
	.option('-e --endpoint <url>', 'sparql endpoint')
	.parse(process.argv);

co(start(Commander));

function* start(args) {
	if (args.scenario && args.mapping) {
		const mapping = JSON.parse(
			yield fs.readFile(args.mapping));
		const scenario = JSON.parse(
			yield fs.readFile(args.scenario));

		const sc = createSchema(scenario.schema, mapping);

		const client = sparql(Commander.endpoint, {
			prefixes: sc.prefixes
		});

		co(exec(client, sc, scenario));
	}
}

const distantFuture = xsdDate("9999-01-01");

function xsdDate(value) {
	return `"${value}T00:00:00+01:00"^^xsd:date`;
}

function quote(value) {
	return `"${value}"`;
}

function tuples(n, keys) {
	let ts = [];

	for (let attribute in keys) {
		ts.push(`${n} ${attribute} ${keys[attribute]} .`);
	}
	return ts;
}

function* getSymbolFromKeys(client, entity, keys) {
	const reponse =
		yield client.query(
			`SELECT ?s WHERE { ?s a ${entity} . ${ tuples('?s',keys).join(' ') } }`);
	if (reponse.results.bindings.length > 0) {
		return reponse.results.bindings[0].s.value;
	}
	return undefined;
}

function* insertIfMissing(client, graph, entity, keys) {
	const s =
		yield getSymbolFromKeys(client, entity, keys);

	if (s) {
		return s;
	}

	const response =
		yield client.query(
			`INSERT IN GRAPH <${graph}> { _:s a ${entity} . ${ tuples('_:s',keys).join(' ') } }`
		);
	return yield getSymbolFromKeys(client, entity, keys);
}


function* exec(client, schema, scenario) {
	const graph = schema.graph;

  let spo = 2;
	for (let dsd in scenario.datasets) {

		const t =
			yield insertIfMissing(client, graph, 'time:validity', {
				'time:start': xsdDate(dsd),
				'time:end': distantFuture
			});

		//console.log('t: ' + t);

		const dataset = scenario.datasets[dsd];

		for (let e in dataset) {
			const records = dataset[e];
			const entity = schema.entities[e];

			for (let r of records) {
				let keys = {};

				for (let kan in entity.keyAttributes) {
					keys[entity.keyAttributes[kan].rdfName] = quote(r[kan]);
				}

				const e = yield insertIfMissing(client, graph, entity.rdfName, keys);
        console.log(entity.rdfName + ': ' + e);

        for (let an in entity.plainAttributes) {
          const a = entity.plainAttributes[an];
          console.log("att: " + a.name + " " + a.rdfName + " " + r[an]);
          yield client.query(
            `INSERT IN GRAPH <${graph}> {
              ?e donkey:spo${spo} ${quote(r[an])} .
              donkey:spo${spo} rdf:singletonPropertyOf ${a.rdfName} ;
              time:isValid ?t .
            } WHERE {
              ?t a time:validity ;
                   time:start ${xsdDate(dsd)} ;
                   time:end ${distantFuture} .
              ${tuples('?e',keys).join(' ')}
            }`);
          spo++;
        }
			}
		}
	}
}


function createSchema(definition, mapping) {
	let entities = {};
	let schema = {
		"entities": entities,
		"graph": mapping.graph,
		"prefixes": mapping.prefixes
	};

	for (let en in definition) {
		let attributes = definition[en];
		const m = mapping.entities[en];
		let entity = {
			"name": en,
			"rdfName": m.a,
			"attributes": attributes,
			"references": {},
			"plainAttributes": {},
			"keyAttributes": {}
		};

		entities[en] = entity;

		for (let an in attributes) {
			let attribute = attributes[an];
			attribute.name = an;
			attribute.rdfName = m.attributes[an];

			if (attribute.isKey) {
				entity.keyAttributes[an] = attribute;
			} else if (!attribute.references) {
				entity.plainAttributes[an] = attribute;
			}
		}

		//console.log("entity: " + entity.name + " " + entity.rdfName);
		//console.log("attributes: " + JSON.stringify(entity.attributes));
	}

	for (let en in schema.entities) {
		const e = schema.entities[en];

		for (let an in e.attributes) {
			const a = e.attributes[an];

			if (a.references) {
				const r = schema.entities[a.references];
				if (!r) {
					console.log(e.name + " reference not found: " + a.references);
				}

				a.refernces = r;
				e.references[an] = a;
			}
		}
	}

	return schema;
}
